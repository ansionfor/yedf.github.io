# 架构

## 架构与角色

dtm包括服务端和客户端，整体架构图如下：

![arch](../imgs/arch.jpg)

整个分布式事务的运行过程中，一共有三个角色参与，和OPEN/X XA事务标准类似，但也会有一些区别

- RM-资源管理器：RM管理分布式事务中的本地事务，负责相关数据的修改、提交、回滚、补偿等操作。通常对应一个微服务。
- AP-应用程序：AP会注册全局事务，按照业务规则，注册子事务，调用RM接口。通常对应一个微服务。
- TM-事务管理器：每个全局事务在TM注册，每个子事务也注册到TM。TM会协调所有的RM，将同一个全局事务的不同子事务，全部提交或全部回滚。对应dtm服务实例。

## 高可用

在DTM架构下，TM由dtm服务构成，每个dtm实例都是无状态的应用程序，他们将全局事务数据存储在dtm的数据库。实际业务只要给dtm配置了高可用的数据库，那么整个dtm服务就是天然高可用的。

在简单部署模式下，一方面每个dtm都提供rest服务，接受AP的事务请求。另一方面dtm还会启动一个协程，定时查询超时需要处理的全局事务，重试之前状态不确定的事务分支。

## 嵌套子事务

dtm的Tcc事务模式，支持子事务嵌套，流程图如下：

![nested_trans](../imgs/nested_trans.jpg)

在这个流程图中，Order这个微服务，管理了订单相关的数据修改，同时还管理了一个嵌套的子事务，因此他即扮演了RM的角色，也扮演了AP的角色。

## 角色间通信协议

目前dtm只支持了http协议。由于分布式事务涉及多个角色协作，某些参与者可能出现暂时不可用，需要重试；某些参与者明确告知失败，需要进行回滚。
下面对各种情况进行分类说明，定义各类情况的返回值。接口类似微信/支付宝订单成功回调的接口，如果接口返回的结果中，包含SUCCESS，则表示成功；其他则表示出错，需要进行重试。

上面的架构图中，主要有以下几类接口：

AP调用TM的接口，主要为全局事务注册、提交，子事务注册等：
  - 成功: { dtm_result: "SUCCESS" }
  - 失败: { dtm_result: "FAILURE" }，表示这个请求状态不对，例如已经走fail的全局事务不允许再注册分支
  - 其他表示状态不确定，可重试

TM调用RM的接口，主要为二阶段的提交、回滚，以及saga的各分支
  - 成功: { dtm_result: "SUCCESS" }，表示这个接口调用成功，正常进行下一步操作
  - 失败: { dtm_result: "FAILURE" }，表示这个接口调用失败，全局事务需要进行回滚。例如saga中的正向操作如果返回FAILURE，则整个saga事务失败回滚
  - 其他则需要重试（结果不确定，需要重试）

AP调用RM的接口，跟业务相关，建议的接口形式（非必须）：
  - 成功: { dtm_result: "SUCCESS" }，表示这个接口调用成功，正常进行下一步操作。返回的结果还可以包含其他业务数据。
  - 失败: { dtm_result: "FAILURE" }，表示这个接口调用失败，全局事务需要进行回滚。例如tcc中的Try动作如果返回FAILURE，则整个tcc全局事务回滚
  - 其他则需要重试（结果不确定，需要重试）

::: tip 接口数据注意点
dtm框架通过resp.String()是否包含SUCCESS/FAILURE来判断成功和失败，因此请避免在子事务接口返回的业务数据里包含这两个词。
:::

## 重试策略

dtm定时轮询超时未完成的全局事务，重试间隔时间每次加倍，当超过1小时还未完成，则放弃重试。

如果应用程序由于各类bug或故障导致全局事务在一小时内的重试全都不成功，待开发人员修复bug或故障之后，可以通过手动修改dtm.trans_global中next_cron_time来触发重试。
